<!DOCTYPE html>
<html>
<head>
    <title>WebGL FPS Demo</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            font-family: Arial;
        }
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            pointer-events: none;
        }
        #fpsCounter {
            position: fixed;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            font-family: monospace;
            font-size: 16px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="crosshair">+</div>
    <div id="instructions">
      ZQSD/Flèches pour se déplacer<br>
      A pour monter, E pour descendre<br>
      Souris pour regarder autour
    </div>
    <div id="fpsCounter">FPS: --</div>
    <canvas id="glCanvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script>
        const canvas = document.querySelector("#glCanvas");
        const gl = canvas.getContext("webgl2");

        const maxTextureArrayLayers = gl.getParameter(gl.MAX_ARRAY_TEXTURE_LAYERS);
        console.log('Nombre maximal de couches de texture:', maxTextureArrayLayers);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        if (!gl) {
            alert("WebGL non supporté");
            throw new Error("WebGL non supporté");
        }

        const vsSource = `#version 300 es
            precision mediump float;

            in vec4 aVertexPosition;
            in vec2 aTextureCoord;
            in uint aTextureIndex;
            in vec3 aTintColor;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;

            out vec2 vTextureCoord;
            flat out uint vTextureIndex;
            out vec3 vTintColor;
            out vec3 vFragPosition;

            void main(void) {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                vTextureCoord = aTextureCoord;
                vTextureIndex = aTextureIndex;
                vTintColor = aTintColor;
                vFragPosition = aVertexPosition.xyz;
            }
        `;

        const fsSource = `#version 300 es
            precision mediump float;

            in vec2 vTextureCoord;
            flat in uint vTextureIndex;
            in vec3 vTintColor;
            in vec3 vFragPosition;

            uniform vec3 uPlayerPosition;
            uniform float uLightRadius;
            uniform mediump sampler2DArray uSampler;

            out vec4 fragColor;

            void main(void) {
                vec4 texColor = texture(uSampler, vec3(vTextureCoord, float(vTextureIndex)));
                float distance = length(vFragPosition - uPlayerPosition);
                float attenuation = clamp(1.0 - (distance / uLightRadius), 0.0, 1.0);
                vec3 finalColor = texColor.rgb * vTintColor * attenuation;
                fragColor = vec4(finalColor, texColor.a);
            }
        `;

        const spriteVertexShaderSource = `#version 300 es
          precision mediump float;

          in vec2 aVertexPosition; // Coordonnées du quad
          in vec2 aTextureCoord;

          uniform mat4 uProjectionMatrix;
          uniform mat4 uViewMatrix;
          uniform vec3 uSpritePosition;
          uniform vec3 uCameraRight;
          uniform vec3 uCameraUp;
          uniform float uSpriteWidth;
          uniform float uSpriteHeight;

          out vec2 vTextureCoord;

          void main(void) {
              // Calcul de l'offset en fonction de la taille du sprite
              vec3 offset = aVertexPosition.x * uSpriteWidth * uCameraRight +
                            aVertexPosition.y * uSpriteHeight * uCameraUp;

              vec3 worldPosition = uSpritePosition + offset;

              gl_Position = uProjectionMatrix * uViewMatrix * vec4(worldPosition, 1.0);
              vTextureCoord = aTextureCoord;
          }
        `;

        const spriteFragmentShaderSource = `#version 300 es
          precision mediump float;

          in vec2 vTextureCoord;

          uniform sampler2D uSpriteSampler;

          out vec4 fragColor;

          void main(void) {
              vec4 texColor = texture(uSpriteSampler, vTextureCoord);
              if (texColor.a < 0.1) discard; // Optionnel : gestion de la transparence
              fragColor = texColor;
          }
        `;

        const spriteShaderProgram = initShaderProgram(gl, spriteVertexShaderSource, spriteFragmentShaderSource);
        const spriteProgramInfo = {
            program: spriteShaderProgram,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(spriteShaderProgram, 'aVertexPosition'),
                textureCoord: gl.getAttribLocation(spriteShaderProgram, 'aTextureCoord'),
            },
            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(spriteShaderProgram, 'uProjectionMatrix'),
                viewMatrix: gl.getUniformLocation(spriteShaderProgram, 'uViewMatrix'),
                uSpritePosition: gl.getUniformLocation(spriteShaderProgram, 'uSpritePosition'),
                uCameraRight: gl.getUniformLocation(spriteShaderProgram, 'uCameraRight'),
                uCameraUp: gl.getUniformLocation(spriteShaderProgram, 'uCameraUp'),
                uSpriteSampler: gl.getUniformLocation(spriteShaderProgram, 'uSpriteSampler'),
                uSpriteWidth: gl.getUniformLocation(spriteShaderProgram, 'uSpriteWidth'),
                uSpriteHeight: gl.getUniformLocation(spriteShaderProgram, 'uSpriteHeight'),
            },
        };

        

          // Fonction pour charger une texture
          function loadTexture(url) {
            return new Promise((resolve, reject) => {
                const texture = gl.createTexture();
                const image = new Image();
                image.onload = function() {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                    
                    // Vérifie si l'image est une puissance de 2 dans les deux dimensions
                    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    }
                    resolve(texture);
                };
                image.onerror = reject;
                image.src = url;
            });
        }

        function isPowerOf2(value) {
            return (value & (value - 1)) === 0;
        }

        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Erreur de compilation du shader :', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        const tintColors = [
            [1.0, 1.0, 1.0],   // Blanc (pas de teinte)
            [1.0, 0.8, 0.8],   // Teinte rouge clair
            [0.8, 1.0, 0.8],   // Teinte vert clair
            [0.8, 0.8, 1.0],   // Teinte bleu clair
            [1.0, 1.0, 0.8],   // Teinte jaune clair
            [1.0, 0.8, 1.0],   // Teinte magenta clair
            [0.8, 1.0, 1.0],   // Teinte cyan clair
            [0.9, 0.9, 0.9]    // Gris clair
            // ... ajoutez d'autres teintes si nécessaire
        ];

        // Nouvelle structure pour stocker les blocs
        const mapSize = { x: 256, y: 256, z: 256 };
        const map = new Array(mapSize.z).fill(0).map(() => new Array(mapSize.x * mapSize.y));

        function initMap() {
          console.log('Initialisation de la carte...');
            for (let z = 0; z < mapSize.z; z++) {
                for (let y = 0; y < mapSize.y; y++) {
                    for (let x = 0; x < mapSize.x; x++) {
                        let type = 0; // Air par défaut
                        if (z === 0) {
                            //sol type 1 ou 3
                            type = Math.random() < 0.5 ? 1 : 3;
                        } else {
                          //bloc type 2 ou 4 50% de chance ou rien
                          if(Math.random() < 0.5) {
                            type = Math.random() < 0.5 ? 2 : 4;
                          }
                        }
                        const block = {
                            type: type,
                            tintIndex: Math.floor(Math.random() * tintColors.length),
                            heightRatio: Math.random() * 0.8 + 0.2 // Hauteur entre 0.2 et 1.0
                        }
                        map[z][y * mapSize.x + x] = block;
                    }
                }
            }
        }



        const sprites = [
            {
                position: [5.5, 5.5, 5.0], // Position dans le monde (x, y, z)
                textureIndex: 0,           // Indice de la texture à utiliser
                width: 0.7,                // Largeur du sprite
                height: 0.7,               // Hauteur du sprite
            },
            // Ajoutez d'autres sprites ici
        ];

        //randomly add 1000 sprites with texture index 0 to 10
        // for(let i = 0; i < 1000; i++) {
        //   sprites.push({
        //     position: [Math.random() * 256, Math.random() * 256, Math.random() * 256],
        //     textureIndex: Math.floor(Math.random() * 10),
        //     width: 0.7,
        //     height: 0.7
        //   });
        // }


        function setBlock(x, y, z, type, tintIndex = 0, heightRatio = 1.0) {
            map[z][y * mapSize.x + x] = {type, tintIndex, heightRatio};
        }

        // Fonction pour obtenir le type de bloc à une position donnée
        function getBlock(x, y, z) {
            if (x < 0 || y < 0 || z < 0 || x >= mapSize.x || y >= mapSize.y || z >= mapSize.z) {
                return undefined; // Hors de la carte
            }
            return map[z][y * mapSize.x + x];
        }
        
        const LOAD_RADIUS = 20; // Rayon en unités autour du joueur
        const CHUNK_SIZE = 10;
        let lastPlayerChunk = { x: 0, y: 0, z: 0 };


        function rayCast(position, direction, maxDistance = 5) {
            const startOffset = 0.1;
            let px = position[0] + direction[0] * startOffset;
            let py = position[1] + direction[1] * startOffset;
            let pz = position[2] + direction[2] * startOffset;

            const dx = direction[0];
            const dy = direction[1];
            const dz = direction[2];

            const step = 0.05;
            const steps = maxDistance / step;

            let lastEmpty = null;
            let lastX = Math.floor(px);
            let lastY = Math.floor(py);
            let lastZ = Math.floor(pz);

            for (let i = 0; i < steps; i++) {
                px += dx * step;
                py += dy * step;
                pz += dz * step;

                const x = Math.floor(px);
                const y = Math.floor(py);
                const z = Math.floor(pz);

                if (x !== lastX || y !== lastY || z !== lastZ) {
                    if (getBlock(lastX, y, lastZ) !== 2) {
                        lastEmpty = [lastX, y, lastZ];
                    }
                    lastX = x;
                    lastY = y;
                    lastZ = z;
                }

                if (getBlock(x, y, z) !== 0) {
                    return {
                        hit: true,
                        position: [x, y, z],
                        previous: lastEmpty,
                        distance: i * step
                    };
                }
            }

            return { hit: false };
        }


        canvas.addEventListener('mousedown', (e) => {
            if (document.pointerLockElement === canvas) {
                const pos = [camera.x, camera.y, camera.z];
                const result = rayCast(pos, camera.direction);

                if (e.button === 0) { // Clic gauche - Placer un bloc
                    if (result.hit && result.previous) {
                        const [x, y, z] = result.previous;
                        // Vérifier qu'on ne place pas un bloc à notre position
                        const playerX = Math.floor(camera.x);
                        const playerY = Math.floor(camera.z);
                        const playerZ = Math.floor(camera.y);

                        if (!(x === playerX && y === playerY && z === playerZ) &&
                            !(x === playerX && y === playerY - 1 && z === playerZ)) {
                            const blockType = keys['shift'] ? 4 : 2;
                            const tintIndex = Math.floor(Math.random() * tintColors.length);
                            const heightRatio = Math.random() * 0.8 + 0.2; // Hauteur entre 0.2 et 1.0
                            setBlock(x, y, z, blockType, tintIndex, heightRatio);
                            buffers = initBuffers(gl);
                        }
                    }
                } else if (e.button === 2) { // Clic droit - Détruire un bloc
                    if (result.hit) {
                        const [x, y, z] = result.position;
                        if (getBlock(x, y, z) !== 0) {
                            setBlock(x, y, z, 0); // Utiliser setBlock pour supprimer le bloc dans 'world'
                            buffers = initBuffers(gl);
                        }
                    }
                }
            }
        });

        // Empêcher le menu contextuel sur clic droit
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        const camera = {
            x: 50.5,
            y: 50.5, // Position sur l'axe Y (profondeur)
            z: 50.7, // Hauteur (axe Z)
            pitch: 0,
            yaw: 0,
            direction: vec3.create(),
            up: vec3.fromValues(0, 0, 1), // L'axe Z est maintenant l'axe vertical
            right: vec3.create(),
            updateVectors: function() {
                // Calculer la direction avec Z comme axe vertical
                this.direction[0] = Math.cos(this.pitch) * Math.sin(this.yaw);
                this.direction[1] = Math.cos(this.pitch) * Math.cos(this.yaw);
                this.direction[2] = Math.sin(this.pitch); // Z est maintenant la hauteur

                vec3.normalize(this.direction, this.direction);

                // Recalculer le vecteur "right"
                vec3.cross(this.right, this.direction, this.up);
                vec3.normalize(this.right, this.right);
            },
        };

        let keys = {};
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;

        canvas.onclick = () => {
            canvas.requestPointerLock();
        };

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === canvas) {
                const sensitivity = 0.002;
                camera.yaw += e.movementX * sensitivity;
                camera.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, camera.pitch - e.movementY * sensitivity));
                camera.updateVectors();
            }
        });

        function initSpriteBuffers(gl) {
            // Quad centré sur (0,0) de taille 1x1
            const positions = [
                -0.5, 0.0,  // Coin inférieur gauche
                0.5, 0.0,  // Coin inférieur droit
                0.5, 1.0,  // Coin supérieur droit
                -0.5, 1.0,  // Coin supérieur gauche
            ];

            const textureCoordinates = [
                0.0, 1.0,   // Correspondance avec la texture
                1.0, 1.0,
                1.0, 0.0,
                0.0, 0.0,
            ];

            const indices = [0, 1, 2, 0, 2, 3];

            // Buffer des positions
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            // Buffer des coordonnées de texture
            const textureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);

            // Buffer des indices
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            return {
                position: positionBuffer,
                textureCoord: textureCoordBuffer,
                indices: indexBuffer,
                count: indices.length,
            };
        }

        function initBuffers(gl) {
            const positions = [];
            const textureCoordinates = [];
            const textureIndices = [];
            const colors = [];
            const indices = [];
            let indexOffset = 0;

            // parourir la carte pour générer les blocs autours du joueur
            const posX = Math.floor(camera.x);
            const posY = Math.floor(camera.y);
            const posZ = Math.floor(camera.z);

            console.log('Génération des blocs autour de', posX, posY, posZ);

            const treateBlock = (x, y, z) => {
              const blockData = getBlock(x, y, z);
                if (!blockData || blockData.type === 0) return; // Air
                const type = blockData.type;
                const tintIndex = blockData.tintIndex;
                const heightRatio = blockData.heightRatio;
                const tintColor = tintColors[tintIndex];


                // Déterminer l'indice de texture en fonction du type
                let texIndex;
                if (type === 1) texIndex = 0;
                else if (type === 3) texIndex = 1;
                else if (type === 2) texIndex = 2;
                else if (type === 4) texIndex = 3;
                else return; // Type de bloc inconnu;

                if (type === 1 || type === 3) { // Sols
                    // Positions pour la face supérieure du sol (hauteur fixe)
                    positions.push(
                        x, y, z,
                        x + 1, y, z,
                        x + 1, y + 1, z,
                        x, y + 1, z
                    );

                    // Coordonnées de texture
                    textureCoordinates.push(
                        0.0, 0.0,
                        1.0, 0.0,
                        1.0, 1.0,
                        0.0, 1.0
                    );

                    // Indices de texture et couleurs
                    for (let i = 0; i < 4; i++) {
                        textureIndices.push(texIndex);
                        colors.push(...tintColor);
                    }

                    // Indices pour les triangles
                    indices.push(
                        indexOffset, indexOffset + 1, indexOffset + 2,
                        indexOffset, indexOffset + 2, indexOffset + 3
                    );
                    indexOffset += 4;
                } else if (type === 2 || type === 4) { // Blocs
                    // Positions pour les 6 faces du bloc avec hauteur variable
                    const zBottom = z;
                    const zTop = z + heightRatio; // Utiliser le heightRatio stocké
                    // Face avant (plan y + 1)
                    positions.push(
                        x,     y + 1, zBottom, // Coin inférieur gauche
                        x + 1, y + 1, zBottom, // Coin inférieur droit
                        x + 1, y + 1, zTop,    // Coin supérieur droit
                        x,     y + 1, zTop     // Coin supérieur gauche
                    );
                    // Face arrière
                    positions.push(
                        x,     y, zBottom, // Coin inférieur gauche
                        x + 1, y, zBottom, // Coin inférieur droit
                        x + 1, y, zTop,    // Coin supérieur droit
                        x,     y, zTop     // Coin supérieur gauche
                    );
                    // Face supérieure
                    positions.push(
                        x,     y,     zTop, // Coin arrière gauche
                        x + 1, y,     zTop, // Coin arrière droit
                        x + 1, y + 1, zTop, // Coin avant droit
                        x,     y + 1, zTop  // Coin avant gauche
                    );
                    // Face inférieure (peut être omise si non visible)
                    positions.push(
                        x,     y,     zBottom, // Coin arrière gauche
                        x + 1, y,     zBottom, // Coin arrière droit
                        x + 1, y + 1, zBottom, // Coin avant droit
                        x,     y + 1, zBottom  // Coin avant gauche
                    );
                    // Face droite
                    positions.push(
                        x + 1, y,     zBottom, // Coin inférieur arrière
                        x + 1, y + 1, zBottom, // Coin inférieur avant
                        x + 1, y + 1, zTop,    // Coin supérieur avant
                        x + 1, y,     zTop     // Coin supérieur arrière
                    );
                    // Face gauche
                    positions.push(
                        x, y,     zBottom, // Coin inférieur arrière
                        x, y + 1, zBottom, // Coin inférieur avant
                        x, y + 1, zTop,    // Coin supérieur avant
                        x, y,     zTop     // Coin supérieur arrière
                    );

                    // Coordonnées de texture et couleurs pour chaque face
                    for (let i = 0; i < 6; i++) {
                        textureCoordinates.push(
                            0.0, 0.0,
                            1.0, 0.0,
                            1.0, 1.0,
                            0.0, 1.0
                        );
                        for (let j = 0; j < 4; j++) {
                            textureIndices.push(texIndex);
                            colors.push(...tintColor);
                        }
                    }

                    // Indices pour les triangles de chaque face
                    for (let i = 0; i < 6; i++) {
                        const base = indexOffset + i * 4;
                        indices.push(
                            base, base + 1, base + 2,
                            base, base + 2, base + 3
                        );
                    }
                    indexOffset += 24;
                }
                
            }

            for (let z = posZ + LOAD_RADIUS; z >= posZ - LOAD_RADIUS; z--) {
                for (let y = posY - LOAD_RADIUS; y <= posY + LOAD_RADIUS; y++) {
                    for (let x = posX - LOAD_RADIUS; x <= posX + LOAD_RADIUS; x++) {
                        treateBlock(x, y, z);
                    }
                }
            }

            // Création des buffers WebGL
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const textureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);

            const textureIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureIndexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(textureIndices), gl.STATIC_DRAW);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), gl.STATIC_DRAW);

            return {
                position: positionBuffer,
                textureCoord: textureCoordBuffer,
                textureIndex: textureIndexBuffer,
                color: colorBuffer,
                indices: indexBuffer,
                count: indices.length,
            };
        }

        // Configuration de l'éclairage
        const lightConfig = {
            radius: 8.0  // Rayon de la lumière
        };

        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
        const programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
                textureIndex: gl.getAttribLocation(shaderProgram, 'aTextureIndex'),
                tintColor: gl.getAttribLocation(shaderProgram, 'aTintColor'), // Nouvelle location
            },
            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                playerPosition: gl.getUniformLocation(shaderProgram, 'uPlayerPosition'),
                lightRadius: gl.getUniformLocation(shaderProgram, 'uLightRadius'),
                uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'),
            },
        };

        let buffers = initBuffers(gl);

        function updateCamera() {
            const speed = 0.01;
            if (keys['z'] || keys['arrowup']) {
                camera.x += camera.direction[0] * speed;
                camera.y += camera.direction[1] * speed; // Utiliser camera.y au lieu de camera.z
            }
            if (keys['s'] || keys['arrowdown']) {
                camera.x -= camera.direction[0] * speed;
                camera.y -= camera.direction[1] * speed; // Utiliser camera.y au lieu de camera.z
            }
            if (keys['q'] || keys['arrowleft']) {
                camera.x -= camera.right[0] * speed;
                camera.y -= camera.right[1] * speed; // Utiliser camera.y au lieu de camera.z
            }
            if (keys['d'] || keys['arrowright']) {
                camera.x += camera.right[0] * speed;
                camera.y += camera.right[1] * speed; // Utiliser camera.y au lieu de camera.z
            }

            // Mouvement vertical (hauteur)
            if (keys['a']) {
                camera.z += speed; // Z est maintenant la hauteur
            }
            if (keys['e']) {
                camera.z -= speed; // Z est maintenant la hauteur
            }
        }

        let lastTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        const fpsUpdateInterval = 500; // Mise à jour toutes les 500ms
        const fpsDisplay = document.getElementById('fpsCounter');

        let textures;

        function createTextureArray(gl, images) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D_ARRAY, texture);

            const width = images[0].width;
            const height = images[0].height;
            const depth = images.length;

            // Définir la taille du tableau de textures
            gl.texImage3D(
                gl.TEXTURE_2D_ARRAY, // target
                0,                   // level
                gl.RGBA8,            // internalformat
                width,               // width
                height,              // height
                depth,               // depth (nombre de couches)
                0,                   // border
                gl.RGBA,             // format
                gl.UNSIGNED_BYTE,    // type
                null                 // data (nous allons remplir les données après)
            );

            // Charger chaque image dans le tableau de textures
            images.forEach((image, index) => {
                gl.texSubImage3D(
                    gl.TEXTURE_2D_ARRAY, // target
                    0,                   // level
                    0,                   // xoffset
                    0,                   // yoffset
                    index,               // zoffset (indice de la couche)
                    width,               // width
                    height,              // height
                    1,                   // depth
                    gl.RGBA,             // format
                    gl.UNSIGNED_BYTE,    // type
                    image                // source
                );
            });

            // Configurer les paramètres de la texture
            gl.generateMipmap(gl.TEXTURE_2D_ARRAY);
            gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_T, gl.REPEAT);

            // Désactiver la liaison de la texture
            gl.bindTexture(gl.TEXTURE_2D_ARRAY, null);

            return texture;
        }
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const image = new Image();
                image.onload = () => resolve(image);
                image.onerror = reject;
                image.src = url;
            });
        }

        function drawSprites(gl, programInfo, buffers, sprites, modelViewMatrix, projectionMatrix) {
            gl.useProgram(programInfo.program);

            // Configurer les matrices uniformes
            gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
            gl.uniformMatrix4fv(programInfo.uniformLocations.viewMatrix, false, modelViewMatrix);

            // Configurer les attributs
            // Positions du quad
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
            gl.vertexAttribPointer(
                programInfo.attribLocations.vertexPosition,
                2,          // Taille (x, y)
                gl.FLOAT,
                false,
                0,
                0
            );

            // Coordonnées de texture
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);
            gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);
            gl.vertexAttribPointer(
                programInfo.attribLocations.textureCoord,
                2,          // Taille (u, v)
                gl.FLOAT,
                false,
                0,
                0
            );

            // Indices
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);

            // Passer les vecteurs de la caméra au shader
            gl.uniform3fv(programInfo.uniformLocations.uCameraRight, camera.right);
            gl.uniform3fv(programInfo.uniformLocations.uCameraUp, camera.up);

            // Dessiner chaque sprite
            sprites.forEach(sprite => {
                // Passer la position du sprite
                gl.uniform3fv(programInfo.uniformLocations.uSpritePosition, sprite.position);

                // Passer la taille du sprite
                gl.uniform1f(programInfo.uniformLocations.uSpriteWidth, sprite.width);
                gl.uniform1f(programInfo.uniformLocations.uSpriteHeight, sprite.height);

                // Lier la texture du sprite
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, spriteTextures[sprite.textureIndex]);
                gl.uniform1i(programInfo.uniformLocations.uSpriteSampler, 0);

                // Dessiner le sprite
                gl.drawElements(gl.TRIANGLES, buffers.count, gl.UNSIGNED_SHORT, 0);
            });
        }

        const spriteTextures = [];
        let spriteBuffers;

        Promise.all([
        loadTexture('assets/sprites/DWARF_MALE.png'),
        loadTexture('assets/sprites/DWARF_FEMALE.png'),
        loadTexture('assets/sprites/GOBELIN_MALE.png'),
        loadTexture('assets/sprites/GOBELIN_FEMALE.png'),
        loadTexture('assets/sprites/DOG_MALE.png'),
        loadTexture('assets/sprites/DOG_FEMALE.png'),
        loadTexture('assets/sprites/CORPSEPIECE.png'),
        loadTexture('assets/sprites/CHAIR.png'),
        loadTexture('assets/sprites/BED.png'),
        loadTexture('assets/sprites/BARREL.png'),
        
        ]).then((textures) => {
          for(let texture of textures) {
            spriteTextures.push(texture);
          }
          spriteBuffers = initSpriteBuffers(gl);
        }).catch(error => {
            console.error('Erreur de chargement de la texture du sprite:', error);
        });

        Promise.all([
          loadImage('assets/textures/FLOOR_MINERAL.png'),       // ground1
          loadImage('assets/textures/FLOOR_STONE.png'),     // ground2
          loadImage('assets/textures/WALL_STONE.png'),        // block1
          loadImage('assets/textures/WALL_STONE_SMOOTH.png')       // block2
        ]).then((images) => {
            textures = createTextureArray(gl, images);
            document.querySelector('#instructions').innerHTML = 
                'ZQSD/Flèches pour se déplacer<br>' +
                'Souris pour regarder autour<br>' +
                'Clic gauche pour placer un bloc<br>' +
                'Clic droit pour détruire un bloc';
            initMap();
            buffers = initBuffers(gl);
            requestAnimationFrame(render);
        }).catch(error => {
            console.error('Erreur de chargement des textures:', error);
        });

        const lastCell = { x: 0, y: 0, z: 0 };

        function render(currentTime) {
          currentTime *= 0.001; // Conversion en secondes
          const deltaTime = currentTime - lastTime;
          lastTime = currentTime;

          // Calcul des FPS
          frameCount++;
          if (currentTime - lastFpsUpdate >= fpsUpdateInterval * 0.001) {
              const fps = Math.round(frameCount / (currentTime - lastFpsUpdate));
              fpsDisplay.textContent = `FPS: ${fps} |Position: (${camera.x.toFixed(2)}, ${camera.y.toFixed(2)}, ${camera.z.toFixed(2)})`;
              frameCount = 0;
              lastFpsUpdate = currentTime;
          }

          updateCamera();

          if (Math.floor(camera.x / CHUNK_SIZE) !== lastPlayerChunk.x ||
              Math.floor(camera.y / CHUNK_SIZE) !== lastPlayerChunk.y ||
              Math.floor(camera.z / CHUNK_SIZE) !== lastPlayerChunk.z) {
              lastPlayerChunk.x = Math.floor(camera.x / CHUNK_SIZE);
              lastPlayerChunk.y = Math.floor(camera.y / CHUNK_SIZE);
              lastPlayerChunk.z = Math.floor(camera.z / CHUNK_SIZE);
              buffers = initBuffers(gl);
          }

          gl.viewport(0, 0, canvas.width, canvas.height);
          gl.clearColor(0.0, 0.0, 0.1, 1.0);
          gl.clearDepth(1.0);
          gl.enable(gl.DEPTH_TEST);
          gl.depthFunc(gl.LEQUAL);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

          const fieldOfView = 45 * Math.PI / 180;
          const aspect = canvas.clientWidth / canvas.clientHeight;
          const zNear = 0.1;
          const zFar = 100.0;
          const projectionMatrix = mat4.create();
          mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

          const modelViewMatrix = mat4.create();
          const target = vec3.create();
          vec3.add(target, [camera.x, camera.y, camera.z], camera.direction);

          mat4.lookAt(
              modelViewMatrix,
              [camera.x, camera.y, camera.z], // Position de la caméra
              target,                         // Point que regarde la caméra
              camera.up                       // Vecteur "up" de la caméra
          );

          // Utilisation du shader program
          gl.useProgram(programInfo.program);

          // Réglage des matrices uniformes
          gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
          gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
          gl.uniform3f(programInfo.uniformLocations.playerPosition, camera.x, camera.y, camera.z);
          gl.uniform1f(programInfo.uniformLocations.lightRadius, lightConfig.radius);

          // Lier le buffer de positions
          gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
          gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
          gl.vertexAttribPointer(
              programInfo.attribLocations.vertexPosition,
              3,          // taille (x, y, z)
              gl.FLOAT,   // type
              false,      // normalisé
              0,          // stride
              0           // offset
          );

          // Lier le buffer de coordonnées de texture
          gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);
          gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);
          gl.vertexAttribPointer(
              programInfo.attribLocations.textureCoord,
              2,          // taille (u, v)
              gl.FLOAT,   // type
              false,      // normalisé
              0,          // stride
              0           // offset
          );

          // Lier le buffer des indices de texture
          gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureIndex);
          gl.enableVertexAttribArray(programInfo.attribLocations.textureIndex);
          gl.vertexAttribIPointer(
              programInfo.attribLocations.textureIndex,
              1,                // taille (nombre de composantes)
              gl.UNSIGNED_BYTE, // type (doit correspondre au tableau et au shader)
              0,                // stride
              0                 // offset
          );
          // Lier le buffer d'indices
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);

          gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
          gl.enableVertexAttribArray(programInfo.attribLocations.tintColor);
          gl.vertexAttribPointer(
              programInfo.attribLocations.tintColor,
              3,          // taille (r, g, b)
              gl.FLOAT,   // type
              false,      // normalisé
              0,          // stride
              0           // offset
          );


          // Lier le tableau de textures
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D_ARRAY, textures);
          gl.uniform1i(programInfo.uniformLocations.uSampler, 0);

          // Dessiner tous les éléments
          gl.drawElements(gl.TRIANGLES, buffers.count, gl.UNSIGNED_INT, 0);

          drawSprites(gl, spriteProgramInfo, spriteBuffers, sprites, modelViewMatrix, projectionMatrix);

          requestAnimationFrame(render);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        camera.updateVectors();
    </script>
</body>
</html>